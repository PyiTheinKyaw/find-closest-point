function partition_dataset(points, dimension, split_value):
    left_subset = empty list
    right_subset = empty list

    // Iterate over each point in the dataset
    for point in points:
        // Check the coordinate value along the specified dimension
        if point.coordinate(dimension) < split_value:
            // Point belongs to the left subset
            append point to left_subset
        else:
            // Point belongs to the right subset
            append point to right_subset

    return left_subset, right_subset


function calculate_bounding_box(points):
    // Initialize minimum and maximum coordinates for each dimension
    min_coordinates = [INFINITY, INFINITY, INFINITY]
    max_coordinates = [-INFINITY, -INFINITY, -INFINITY]

    // Iterate over each point to update minimum and maximum coordinates
    for point in points:
        for dim in 0 to 2: // Assuming 3D space
            min_coordinates[dim] = min(min_coordinates[dim], point.coordinate(dim))
            max_coordinates[dim] = max(max_coordinates[dim], point.coordinate(dim))

    // Construct bounding box using minimum and maximum coordinates
    bounding_box = (min_coordinates, max_coordinates)
    return bounding_box


function construct_kd_tree(points, depth):
    // Base case: return empty node if no points or maximum depth reached
    if points is empty or depth >= max_depth:
        return EmptyNode

    // Select optimal splitting plane using SAH
    (dimension, split_value) = select_optimal_splitting_plane(points, dimensions)

    // Partition dataset based on splitting plane
    (left_subset, right_subset) = partition_dataset(points, dimension, split_value)

    // Create current node
    node = Node(dimension, split_value)

    // Recursively construct child nodes
    node.left = construct_kd_tree(left_subset, depth + 1)
    node.right = construct_kd_tree(right_subset, depth + 1)

    return node

function select_optimal_splitting_plane(points, dimensions):
    min_cost = INFINITY
    optimal_dimension = 0
    optimal_split_value = 0.0

    // Iterate over all dimensions
    for dim in 0 to dimensions - 1:
        // Sort points along the current dimension
        sorted_points = sort(points, by dimension dim)

        // Iterate over potential splitting values
        for i in 1 to length(sorted_points) - 1:
            split_value = (sorted_points[i - 1].coordinate(dim) + sorted_points[i].coordinate(dim)) / 2.0
            sah_cost = calculate_sah_cost(sorted_points, dim, split_value)

            // Update optimal splitting plane if SAH cost is lower
            if sah_cost < min_cost:
                min_cost = sah_cost
                optimal_dimension = dim
                optimal_split_value = split_value

    return (optimal_dimension, optimal_split_value)

function calculate_sah_cost(points, dimension, split_value):
    left_subset = points with coordinates < split_value along dimension
    right_subset = points with coordinates >= split_value along dimension

    // Calculate bounding boxes for left and right subsets
    left_box = calculate_bounding_box(left_subset)
    right_box = calculate_bounding_box(right_subset)

    // Compute surface areas of bounding boxes
    surface_area_left = calculate_surface_area(left_box)
    surface_area_right = calculate_surface_area(right_box)

    // Calculate SAH cost
    sah_cost = (number of points in left_subset * surface_area_left)
             + (number of points in right_subset * surface_area_right)
    return sah_cost

function calculate_surface_area(min_coordinates, max_coordinates):
    // Calculate the dimensions of the bounding box
    width = max_coordinates[0] - min_coordinates[0]
    height = max_coordinates[1] - min_coordinates[1]
    depth = max_coordinates[2] - min_coordinates[2]

    // Calculate the surface area of the bounding box
    surface_area = 2 * (width * height + height * depth + depth * width)

    return surface_area


--------------------------------------

function select_optimal_splitting_plane(points, min_points_per_subset, min_surface_area):
    // Base case: If number of points falls below threshold, return None
    if size(points) < 2 * min_points_per_subset:
        return None

    // Find dimension with the largest range
    largest_range_dimension = find_dimension_with_largest_range(points, dimensions)

    // Sort points along the dimension with the largest range
    sorted_points = sort(points, by dimension largest_range_dimension)

    // Calculate median value along the selected dimension
    median_index = length(sorted_points) / 2
    median_value = sorted_points[median_index].coordinate(largest_range_dimension)

    calculate_sah_cost {
        // Partition the dataset into left and right subsets based on the median value
        left_subset = []
        right_subset = []
        for point in sorted_points:
            if point.coordinate(largest_range_dimension) < median_value:
                append point to left_subset
            else:
                append point to right_subset

        // Calculate bounding boxes for left and right subsets
        left_bbox = calculate_bounding_box(left_subset)
        right_bbox = calculate_bounding_box(right_subset)

        // Calculate SAH cost for the splitting plane
        sah_cost = calculate_sah_cost(left_subset, right_subset, left_bbox, right_bbox)
    }
        // Return the dimension, split value, and SAH cost for the current splitting plane
        return (largest_range_dimension, median_value, sah_cost)


function construct_kd_tree(points, depth, min_points_per_subset, min_surface_area):
    // Base case: If number of points falls below threshold, return None
    if size(points) < 2 * min_points_per_subset:
        return None

    // Determine current dimension based on depth (alternates between x, y, z)
    dimension = depth % 3

    // Select optimal splitting plane for the current subset of points
    // Sort will be done in select_optimal_splitting_plane
    (splitting_dimension, split_value, _) = select_optimal_splitting_plane(points, min_points_per_subset, min_surface_area)

    // Partition the dataset into left and right subsets based on the selected splitting plane
    left_subset = []
    right_subset = []
    for point in points:
        if point.coordinate(splitting_dimension) < split_value:
            append point to left_subset
        else:
            append point to right_subset

    // Recursively construct kd-trees for left and right subsets
    left_child = construct_kd_tree(left_subset, depth + 1, min_points_per_subset, min_surface_area)
    right_child = construct_kd_tree(right_subset, depth + 1, min_points_per_subset, min_surface_area)

    // Create a node for the current splitting plane
    node = Node(dimension=splitting_dimension, split_value=split_value)
    node.left_child = left_child
    node.right_child = right_child

    return node

function find_dimension_with_largest_range(points, dimensions):
    // Initialize variables to track dimension with largest range and its associated range value
    largest_range_dimension = 0
    largest_range_value = -INFINITY

    // Iterate over each dimension
    for dim in 0 to dimensions - 1:
        // Initialize variables to track minimum and maximum coordinate values along current dimension
        min_coordinate = +INFINITY
        max_coordinate = -INFINITY

        // Find minimum and maximum coordinate values along current dimension
        for point in points:
            coordinate_value = point.coordinate(dim)
            min_coordinate = min(min_coordinate, coordinate_value)
            max_coordinate = max(max_coordinate, coordinate_value)

        // Calculate range of coordinate values along current dimension
        range_value = max_coordinate - min_coordinate

        // Update largest range dimension if current range is larger
        if range_value > largest_range_value:
            largest_range_dimension = dim
            largest_range_value = range_value

    return largest_range_dimension

function create_internal_node(splitting_dimension, split_value, sah_cost):
    // Create a new internal node
    node = InternalNode()

    // Set the splitting dimension, split value, and SAH cost
    node.splitting_dimension = splitting_dimension
    node.split_value = split_value
    node.sah_cost = sah_cost

    // Return the created internal node
    return node




    as_ref
    iter vs intro_inter
--------------

In the context of constructing a KD-tree, an internal node typically does not store individual points from the dataset. Instead, it serves as a structural element within the tree, representing a splitting plane that divides the dataset into two subsets.